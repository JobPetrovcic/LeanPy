from Structures.Expression.Expression import *
from Structures.Expression.Level import *
from Structures.Name import *
from Kernel.TypeChecker import TypeChecker
from Structures.Environment.Declaration.Declaration import Declaration as Declaration, RecursorRule
from Structures.Environment.ReducibilityHint import ReducibilityHint as ReducibilityHint
from _typeshed import Incomplete
from typing import Any, Iterator, Sequence

class FormatError(Exception):
    message: Incomplete
    def __init__(self, message: str) -> None: ...

class LeanFormatParser:
    expression_count: int
    decleration_count: int
    type_checker: Incomplete
    def __init__(self, lean_format_lines: str | Iterator[str]) -> None: ...
    hierarchical_names: Incomplete
    expressions: Incomplete
    universes: Incomplete
    recursor: Incomplete
    def init_processing_lists(self) -> None: ...
    def process(self, lines: Iterator[str]): ...
    def assert_parts_tag(self, parts: list[str], tag: str, tag_pos: int): ...
    @staticmethod
    def process_types(parts: Sequence[object], expected_types: list[type]) -> list[Any]: ...
    def read_multiple_input(self, le: int, parts: list[str], expected_type: type) -> tuple[list[Any], list[str]]: ...
    def read_all(self, parts: list[str], expected_type: type) -> list[Any]: ...
    def add_content_to_hierarchical_name(self, hid: int, decl: Declaration): ...
    def add_hierarchical_name(self, hp_hid: int, hid: int, name: str): ...
    def get_hierarchical_name(self, hid: int) -> Name: ...
    def add_recursor_rule(self, rid: int, rule: RecursorRule): ...
    def get_recursor_rule(self, rid: int) -> RecursorRule: ...
    def process_namespace_name(self, parts: list[str]): ...
    def process_namespace_id(self, parts: list[str]): ...
    def add_universe(self, uid: int, universe: Level): ...
    def get_universe(self, uid: int) -> Level: ...
    def get_universes(self, uids: list[int]) -> list[Level]: ...
    def read_universes(self, parts: list[str]) -> list[Level]: ...
    def add_universe_successor(self, parts: list[str]): ...
    def add_universe_max(self, parts: list[str]): ...
    def add_universe_impredicative_max(self, parts: list[str]): ...
    def add_universe_parameter(self, parts: list[str]): ...
    def add_expression(self, eid: int, expression: Expression): ...
    def get_expression(self, eid: int) -> Expression: ...
    def add_expression_variable(self, parts: list[str]): ...
    def add_expression_sort(self, parts: list[str]): ...
    def add_expression_constant(self, parts: list[str]): ...
    def add_expression_apply(self, parts: list[str]): ...
    def add_expression_lambda(self, parts: list[str]): ...
    def add_expression_let(self, parts: list[str]): ...
    def add_expression_pi(self, parts: list[str]): ...
    def add_expression_proj(self, parts: list[str]): ...
    def add_expression_nat_lit(self, parts: list[str]): ...
    def add_expression_string_lit(self, parts: list[str]): ...
    def get_lvl_params(self, hids: list[int]) -> list[LevelParam]: ...
    def read_lvl_params(self, parts: list[str]) -> list[LevelParam]: ...
    def add_definition(self, parts: list[str]): ...
    def add_theorem(self, parts: list[str]): ...
    def add_opaque(self, parts: list[str]): ...
    def add_axiomatic_definition(self, parts: list[str]): ...
    def add_inductive_definition(self, parts: list[str]): ...
    def add_quotient_definition(self, parts: list[str]) -> None: ...
    def add_constructor_definition(self, parts: list[str]): ...
    def add_recursor_rule_definition(self, parts: list[str]): ...
    def add_recursor_definition(self, parts: list[str]): ...
    def process_line(self, line: str): ...
    @staticmethod
    def from_file(file_path: str): ...
    @staticmethod
    def load_type_checking_environment(file_path: str) -> TypeChecker: ...

def hex_list_to_string(hex_list: list[int]) -> str: ...
def str_list_to_hex_list(str_list: list[str]) -> list[int]: ...
