from Structures.Expression.Level import *
from _typeshed import Incomplete
from typing import Callable, Sequence

def to_offset(level: Level) -> tuple[Level, int]: ...
def from_offset(level: Level, offset: int) -> Level: ...
def is_not_zero(level: Level) -> bool: ...
def make_imax(l: Level, r: Level) -> Level: ...
def push_max_args(l: Level, lst: list[Level]) -> None: ...

lvl_class_to_int: dict[type[Level], int]

def is_norm_lt(a: Level, b: Level) -> bool: ...
def lt_compare(a: Level, b: Level) -> int: ...

key_lt: Incomplete

def is_explicit(l: Level) -> bool: ...
def make_max_pair(l1: Level, l2: Level) -> Level: ...
def make_max(args: list[Level]) -> Level: ...
def normalize(l: Level) -> Level: ...
def are_unique_level_params(levels: Sequence[Level]) -> bool: ...
def is_any_max(level: Level) -> bool: ...
def is_equivalent(l: Level, r: Level) -> bool: ...
def is_equivalent_list(l: list[Level], r: list[Level]) -> bool: ...
def replace_level(level: Level, fn: Callable[[Level], Level | None]) -> Level: ...
LevelSubList = list[tuple[LevelParam, Level]]

def substitute_level_params_level(level: Level, params: LevelSubList) -> Level: ...
