from Structures.Environment.NatReduction import *
from Structures.Expression.Expression import *
from Structures.Expression.Level import *
from Structures.Environment.Declaration.Declaration import Axiom, Constructor, Declaration as Declaration, DeclarationInfo as DeclarationInfo, Definition, Inductive, Opaque, Quot, Recursor, Theorem
from Structures.Environment.Environment import Environment
from Structures.Expression.ExpressionManipulation import ReductionStatus
from Structures.Name import Name as Name
from _typeshed import Incomplete
from typing import Sequence

class TypeChecker:
    allow_loose_infer: Incomplete
    whnf_cache: Incomplete
    whnf_core_cache: Incomplete
    infer_cache: Incomplete
    equiv_manager: Incomplete
    environment: Incomplete
    local_context: Incomplete
    def __init__(self, allow_loose_infer: bool = False, environment: Environment | None = None) -> None: ...
    def remove_fvar(self, fvar: FVar): ...
    def get_type_of_fvar(self, fvar: FVar) -> Expression: ...
    def get_value_of_fvar(self, fvar: FVar) -> Expression | None: ...
    def instantiate(self, body: Expression, val: Expression) -> Expression: ...
    def instantiate_multiple(self, body: Expression, vals: Sequence[Expression]) -> Expression: ...
    def create_fvar(self, name: Name, type: Expression, val: Expression | None, is_let: bool) -> FVar: ...
    def instantiate_fvar(self, bname: Name, arg_type: Expression, arg_val: Expression | None, body: Expression, is_let: bool = False) -> tuple[FVar, Expression]: ...
    def instantiate_fvar_multiple_bodies(self, bname: Name, arg_type: Expression, arg_val: Expression | None, bodies: list[Expression], is_let: bool = False) -> tuple[FVar, list[Expression]]: ...
    def abstract(self, fvar: FVar, expr: Expression) -> Expression: ...
    def ensure_pi(self, expr: Expression) -> Pi: ...
    def is_structure_like(self, decl_name: Name) -> bool: ...
    def is_prop(self, e: Expression): ...
    def def_eq_sort(self, l: Sort, r: Sort) -> bool: ...
    def def_eq_const(self, l: Const, r: Const) -> bool: ...
    def def_eq_app(self, l: App, r: App) -> bool: ...
    def def_eq_pi(self, l: Pi, r: Pi) -> bool: ...
    def def_eq_lambda(self, l: Lambda, r: Lambda) -> bool: ...
    def try_structural_eta_expansion_core(self, t: Expression, s: Expression) -> bool: ...
    def try_structural_eta_expansion(self, l: Expression, r: Expression) -> bool: ...
    def try_eta_expansion_core(self, t: Expression, s: Expression) -> bool: ...
    def try_eta_expansion(self, t: Expression, s: Expression) -> bool: ...
    def def_eq_easy(self, l: Expression, r: Expression) -> bool | None: ...
    def def_eq_proof_irrel(self, t: Expression, s: Expression) -> bool | None: ...
    def def_eq_unit_like(self, t: Expression, s: Expression) -> bool: ...
    def def_eq_core(self, l: Expression, r: Expression) -> bool: ...
    def def_eq(self, l: Expression, r: Expression) -> bool: ...
    def beta_reduction(self, f: Expression, args: list[Expression]) -> Expression: ...
    def is_delta(self, expr: Expression) -> tuple[Const, Definition | Opaque | Theorem, list[Expression]] | None: ...
    def delta_reduction_core(self, fn: Const, decl: Definition | Opaque | Theorem, args: list[Expression]) -> Expression: ...
    def delta_reduction(self, expr: Expression) -> Expression | None: ...
    def reduce_proj_core(self, proj_struct: Expression, idx: int) -> Expression | None: ...
    def reduce_proj(self, proj: Proj, cheap_rec: bool, cheap_proj: bool) -> Expression | None: ...
    def try_unfold_proj_app(self, e: Expression) -> Expression | None: ...
    def lazy_delta_reduction_step(self, t_n: Expression, s_n: Expression) -> tuple[Expression, Expression, ReductionStatus]: ...
    def lazy_delta_reduction(self, t_n: Expression, s_n: Expression) -> tuple[Expression, Expression, bool | None]: ...
    def lazy_delta_proj_reduction(self, t_n: Expression, s_n: Expression, idx: int) -> bool: ...
    def reduce_nat_lit(self, e: Expression) -> Expression | None: ...
    def reduce_native(self, e: Expression) -> Expression | None: ...
    def get_first_constructor(self, inductive_name: Name) -> Constructor | None: ...
    def expand_eta_struct(self, e_type: Expression, e: Expression): ...
    def to_constructor_when_structure(self, inductive_name: Name, e: Expression) -> Expression: ...
    def mk_nullary_constructor(self, type_e: Expression, num_params: int) -> Expression | None: ...
    def to_constructor_when_K(self, recursor: Recursor, e: Expression, cheap_rec: bool, cheap_proj: bool) -> Expression: ...
    def quot_reduce_rec(self, e: Expression) -> Expression | None: ...
    def reduce_recursor(self, e: Expression, cheap_rec: bool, cheap_proj: bool) -> Expression | None: ...
    def whnf_fvar(self, fvar: FVar, cheap_rec: bool, cheap_proj: bool) -> Expression: ...
    def whnf_core(self, expr: Expression, cheap_rec: bool, cheap_proj: bool) -> Expression: ...
    def whnf(self, init_expr: Expression) -> Expression: ...
    def infer_fvar(self, fvar: FVar): ...
    def infer_app(self, app: App, infer_only: bool) -> Expression: ...
    def infer_sort(self, sort: Sort) -> Expression: ...
    def infer_pi(self, pi: Pi, infer_only: bool) -> Expression: ...
    def ensure_sort(self, e: Expression) -> Sort: ...
    def infer_lambda(self, e: Lambda, infer_only: bool) -> Expression: ...
    def infer_const(self, c: Const) -> Expression: ...
    def make_let_binding(self, fvars: list[FVar], b: Expression) -> Expression: ...
    def infer_let(self, e: Let, infer_only: bool) -> Expression: ...
    def proj_get_constructor(self, proj: Proj, infer_only: bool) -> tuple[Const, Inductive, Constructor, list[Expression]] | None: ...
    def infer_proj(self, proj: Proj, infer_only: bool) -> Expression: ...
    def infer_nat_lit(self, n: NatLit) -> Expression: ...
    def infer_string_lit(self, s: StrLit) -> Expression: ...
    def infer_core(self, expr: Expression, infer_only: bool) -> Expression: ...
    def infer(self, expr: Expression) -> Expression: ...
    def check_declaration_info(self, info: DeclarationInfo): ...
    def add_definition(self, name: Name, d: Definition): ...
    def add_theorem(self, name: Name, t: Theorem): ...
    def add_opaque(self, name: Name, o: Opaque): ...
    def add_axiom(self, name: Name, a: Axiom): ...
    def add_inductive(self, name: Name, ind: Inductive): ...
    def add_constructor(self, name: Name, constructor: Constructor): ...
    def number_of_added_constructors(self, inductive_decl: Inductive) -> int: ...
    def check_inductive_declaration_infos(self, inductive: Name): ...
    def add_recursor(self, name: Name, recursor: Recursor): ...
    def add_quotient(self, name: Name, q: Quot): ...
    def add_declaration(self, name: Name, decl: Declaration): ...
