ADDING INDUCTIVE :  .MyNat
CHECKING NEW EXPRESSION Sort 1
inferered type : Sort 2
ADDED INDUCTIVE :  .MyNat
ADDING CONSTRUCTOR:  .MyNat.zero
CHECKING NEW EXPRESSION .MyNat.{}
inferered type : Sort 1
ADDED CONSTRUCTOR :  .MyNat.zero
ADDING CONSTRUCTOR:  .MyNat.succ
CHECKING NEW EXPRESSION (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) -> (.MyNat.{})
inferered type : Sort IMax(1, 1)
ADDED CONSTRUCTOR :  .MyNat.succ
ADDING RECURSOR :  .MyNat.rec
CHECKING NEW EXPRESSION (.motive : (.t : .MyNat.{}) -> (Sort .u)) -> ((.zero : (db0) (.MyNat.zero.{})) -> ((.succ : (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) -> ((.a_ih._@.TestProject.Basic._hyg.6 : (db2) (db0)) -> ((db3) ((.MyNat.succ.{}) (db1))))) -> ((.t : .MyNat.{}) -> ((db3) (db0)))))
inferered type : Sort IMax(IMax(1, 1 + .u), IMax(.u, IMax(IMax(1, IMax(.u, .u)), IMax(1, .u))))
ADDING RECURSOR RULE :  	RecursionRule for .MyNat.zero with 0 args:
		fun (.motive : (.t : .MyNat.{}) -> (Sort .u)) => (fun (.zero : (db0) (.MyNat.zero.{})) => (fun (.succ : (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) -> ((.a_ih._@.TestProject.Basic._hyg.6 : (db2) (db0)) -> ((db3) ((.MyNat.succ.{}) (db1))))) => (db1)))
ADDING RECURSOR RULE :  	RecursionRule for .MyNat.succ with 1 args:
		fun (.motive : (.t : .MyNat.{}) -> (Sort .u)) => (fun (.zero : (db0) (.MyNat.zero.{})) => (fun (.succ : (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) -> ((.a_ih._@.TestProject.Basic._hyg.6 : (db2) (db0)) -> ((db3) ((.MyNat.succ.{}) (db1))))) => (fun (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) => (((db1) (db0)) (((((.MyNat.rec.{.u}) (db3)) (db2)) (db1)) (db0))))))
ADDED RECURSOR :  .MyNat.rec
ADDING INDUCTIVE :  .PUnit
CHECKING NEW EXPRESSION Sort .u
inferered type : Sort 1 + .u
ADDED INDUCTIVE :  .PUnit
ADDING INDUCTIVE :  .PProd
CHECKING NEW EXPRESSION (.α : Sort .u) -> ((.β : Sort .v) -> (Sort Max(Max(1, .u), .v)))
inferered type : Sort IMax(1 + .u, IMax(1 + .v, 1 + Max(Max(1, .u), .v)))
ADDED INDUCTIVE :  .PProd
ADDING DEFINITION :  .MyNat.below
CHECKING NEW EXPRESSION (.motive : (.t : .MyNat.{}) -> (Sort .u)) -> ((.t : .MyNat.{}) -> (Sort Max(1, .u)))
inferered type : Sort IMax(IMax(1, 1 + .u), IMax(1, 1 + Max(1, .u)))
CHECKING NEW EXPRESSION fun (.motive : (.t : .MyNat.{}) -> (Sort .u)) => (fun (.t : .MyNat.{}) => (((((.MyNat.rec.{1 + Max(1, .u)}) (fun (.t : .MyNat.{}) => (Sort Max(1, .u)))) (.PUnit.{Max(1, .u)})) (fun (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) => (fun (.a_ih._@.TestProject.Basic._hyg.6 : Sort Max(1, .u)) => (((.PProd.{.u, Max(1, .u)}) ((db3) (db1))) (db0))))) (db0)))
inferered type : (.motive : (.t : .MyNat.{}) -> (Sort .u)) -> ((.t : .MyNat.{}) -> ((fun (.t : .MyNat.{}) => (Sort Max(1, .u))) (db0)))
ADDED DEFINITION :  .MyNat.below
INFO TYPE : (.motive : (.t : .MyNat.{}) -> (Sort .u)) -> ((.t : .MyNat.{}) -> (Sort Max(1, .u)))
VALUE : fun (.motive : (.t : .MyNat.{}) -> (Sort .u)) => (fun (.t : .MyNat.{}) => (((((.MyNat.rec.{1 + Max(1, .u)}) (fun (.t : .MyNat.{}) => (Sort Max(1, .u)))) (.PUnit.{Max(1, .u)})) (fun (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) => (fun (.a_ih._@.TestProject.Basic._hyg.6 : Sort Max(1, .u)) => (((.PProd.{.u, Max(1, .u)}) ((db3) (db1))) (db0))))) (db0)))
INFERRED TYPE : (.motive : (.t : .MyNat.{}) -> (Sort .u)) -> ((.t : .MyNat.{}) -> ((fun (.t : .MyNat.{}) => (Sort Max(1, .u))) (.t-0x7f3c8e7f6fb0)))
ADDING CONSTRUCTOR:  .PProd.mk
CHECKING NEW EXPRESSION (.α : Sort .u) -> ((.β : Sort .v) -> ((.fst : db1) -> ((.snd : db1) -> (((.PProd.{.u, .v}) (db3)) (db2)))))
inferered type : Sort IMax(1 + .u, IMax(1 + .v, IMax(.u, IMax(.v, Max(Max(1, .u), .v)))))
ADDED CONSTRUCTOR :  .PProd.mk
ADDING CONSTRUCTOR:  .PUnit.unit
CHECKING NEW EXPRESSION .PUnit.{.u}
inferered type : Sort .u
ADDED CONSTRUCTOR :  .PUnit.unit
ADDING DEFINITION :  .MyNat.brecOn
CHECKING NEW EXPRESSION (.motive : (.t : .MyNat.{}) -> (Sort .u)) -> ((.t : .MyNat.{}) -> ((.F_1 : (.t : .MyNat.{}) -> ((.f : ((.MyNat.below.{.u}) (db2)) (db0)) -> ((db3) (db1)))) -> ((db2) (db1))))
inferered type : Sort IMax(IMax(1, 1 + .u), IMax(1, IMax(IMax(1, IMax(Max(1, .u), .u)), .u)))
CHECKING NEW EXPRESSION fun (.motive : (.t : .MyNat.{}) -> (Sort .u)) => (fun (.t : .MyNat.{}) => (fun (.F_1 : (.t : .MyNat.{}) -> ((.f : ((.MyNat.below.{.u}) (db2)) (db0)) -> ((db3) (db1)))) => ((((((.MyNat.rec.{Max(1, .u)}) (fun (.t : .MyNat.{}) => (((.PProd.{.u, Max(1, .u)}) ((db3) (db0))) (((.MyNat.below.{.u}) (db3)) (db0))))) (((((.PProd.mk.{.u, Max(1, .u)}) ((db2) (.MyNat.zero.{}))) (.PUnit.{Max(1, .u)})) (((db0) (.MyNat.zero.{})) (.PUnit.unit.{Max(1, .u)}))) (.PUnit.unit.{Max(1, .u)}))) (fun (.a._@.TestProject.Basic._hyg.6 : .MyNat.{}) => (fun (.a_ih._@.TestProject.Basic._hyg.6 : ((.PProd.{.u, Max(1, .u)}) ((db3) (db0))) (((.MyNat.below.{.u}) (db3)) (db0))) => (((((.PProd.mk.{.u, Max(1, .u)}) ((db4) ((.MyNat.succ.{}) (db1)))) (((.PProd.{.u, Max(1, .u)}) ((db4) (db1))) (((.MyNat.below.{.u}) (db4)) (db1)))) (((db2) ((.MyNat.succ.{}) (db1))) (db0))) (db0))))) (db1)).0)))
